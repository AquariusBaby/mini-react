{"ast":null,"code":"let nextUnitOfWork = null;\nlet wipRoot = null;\nlet currentRoot = null;\nlet wipFiber = null;\nlet hookIndex = null;\nlet deletions = null; // 要删除的项的数组\n\n/**\n * \n * @param {Object} element \n * @param {Element} container \n */\n\nfunction render(element, container) {\n  wipRoot = {\n    dom: container,\n    props: {\n      children: [element]\n    },\n    alternate: currentRoot\n  };\n  deletions = [];\n  nextUnitOfWork = wipRoot;\n}\n\nfunction _createNode(fiber) {\n  let node = null;\n  let {\n    type,\n    props\n  } = fiber;\n\n  if (type === 'TEXT_ELEMENT') {\n    node = document.createTextNode(props.nodeValue);\n  } else {\n    node = document.createElement(type);\n\n    _updateNode(node, {}, props);\n  } // container.appendChild(node);\n\n\n  return node;\n}\n\nconst isProperty = key => key !== 'children' && !isEvent(key);\n\nconst isNew = (prev, next) => key => prev[key] !== next[key];\n\nconst isGone = (prev, next) => key => !(key in next);\n\nconst isEvent = key => key.startsWith('on');\n\nfunction _updateNode(node, prevProps, nextProps) {\n  // remove old event or change event listeners\n  Object.keys(prevProps).filter(isEvent).filter(key => !(key in nextProps) || isNew(prevProps, nextProps)(key)).forEach(key => {\n    const eventType = key.toLocaleLowerCase().substring(2);\n    node.removeEventListener(eventType, prevProps[key]);\n  }); // add new event listeners\n\n  Object.keys(nextProps).filter(isEvent).filter(isNew(prevProps, nextProps)).forEach(key => {\n    const eventType = key.toLocaleLowerCase().substring(2);\n    node.addEventListener(eventType, nextProps[key]);\n  }); // remove old properties\n\n  Object.keys(prevProps).filter(isProperty).filter(isGone(prevProps, nextProps)).forEach(key => {\n    node[key] = '';\n  }); // set new properties or change properties\n\n  Object.keys(nextProps).filter(isProperty).filter(isNew(prevProps, nextProps)).forEach(key => {\n    node[key] = nextProps[key];\n  }); // nextProps.children.forEach(child => _createNode(child, node));\n}\n\nrequestIdleCallback(workLoop);\n\nfunction workLoop(deadline) {\n  let shouldYield = false; // 循环任务\n\n  while (nextUnitOfWork && !shouldYield) {\n    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n    shouldYield = deadline.timeRemaining() < 1;\n  } // 提交任务\n\n\n  if (!nextUnitOfWork && wipRoot) {\n    commitRoot();\n  }\n\n  requestIdleCallback(workLoop);\n} // 执行任务，并返回下一个任务\n\n\nfunction performUnitOfWork(fiber) {\n  const isFunctionComponent = fiber.type instanceof Function;\n\n  if (isFunctionComponent) {\n    _updateFunctionComponent(fiber);\n  } else {\n    _updateHostComponent(fiber);\n  } // add dom node\n  // if (!fiber.dom) {\n  //     fiber.dom = _createNode(fiber);\n  // }\n  // create new fibers\n  // const elements = fiber.props.children;\n  // reconcileChildren(fiber, elements);\n  // return next unit of work\n\n\n  if (fiber.child) {\n    return fiber.child;\n  }\n\n  let nextFiber = fiber;\n\n  while (nextFiber) {\n    if (nextFiber.sibling) {\n      return nextFiber.sibling;\n    }\n\n    nextFiber = nextFiber.parent;\n  }\n}\n\nfunction reconcileChildren(fiber, elements) {\n  let index = 0;\n  let oldFiber = fiber.alternate && fiber.alternate.child;\n  let prevSibling = null;\n\n  while (index < elements.length || oldFiber != null) {\n    const element = elements[index];\n    let newFiber = null; // compare oldFiber and newFiber\n\n    const isSameType = oldFiber && element && element.type === oldFiber.type;\n\n    if (isSameType) {\n      // 相同的type ===》 update\n      newFiber = {\n        type: oldFiber.type,\n        props: element.props,\n        parent: fiber,\n        dom: oldFiber.dom,\n        alternate: oldFiber,\n        effectTag: \"UPDATE\"\n      };\n    }\n\n    if (!isSameType && element) {\n      // 不同的type，且有element ===》 add\n      newFiber = {\n        type: element.type,\n        props: element.props,\n        parent: fiber,\n        dom: null,\n        alternate: null,\n        effectTag: \"PLACEMENT\"\n      };\n    }\n\n    if (!isSameType && oldFiber) {\n      // 不同的type，且有oldFiber ===》 delete\n      oldFiber.effectTag = \"DELETE\";\n      deletions.push(oldFiber);\n    }\n\n    if (index === 0) {\n      fiber.child = newFiber;\n    } else {\n      prevSibling.sibling = newFiber;\n    }\n\n    if (oldFiber) {\n      oldFiber = oldFiber.sibling;\n    }\n\n    prevSibling = newFiber;\n    index++;\n  }\n}\n\nfunction _updateHostComponent(fiber) {\n  // add dom node\n  if (!fiber.dom) {\n    fiber.dom = _createNode(fiber);\n  } // create new fibers\n\n\n  const elements = fiber.props.children;\n  reconcileChildren(fiber, elements);\n}\n\nfunction _updateFunctionComponent(fiber) {\n  wipFiber = fiber;\n  hookIndex = 0;\n  wipFiber.hooks = [];\n  const elements = [fiber.type(fiber.props)];\n  reconcileChildren(fiber, elements);\n}\n\nfunction commitRoot() {\n  deletions.forEach(commitWork); // 删除\n\n  commitWork(wipRoot.child);\n  currentRoot = wipRoot;\n  wipRoot = null; // 置空wipRoot\n} // 递归wipRoot\n\n\nfunction commitWork(fiber) {\n  if (!fiber) {\n    return;\n  } // const domParent = fiber.parent.dom;\n\n\n  let domParentFiber = fiber.parent;\n\n  while (!domParentFiber.dom) {\n    domParentFiber = domParentFiber.parent;\n  }\n\n  const domParent = domParentFiber.dom;\n\n  if (fiber.effectTag === 'PLACEMENT' && fiber.dom != null) {\n    domParent.appendChild(fiber.dom);\n  }\n\n  if (fiber.effectTag === 'DELETE') {\n    // domParent.removeChild(fiber.dom);\n    commitDeletion(fiber, domParent);\n  }\n\n  if (fiber.effectTag === 'UPDATE' && fiber.dom !== null) {\n    _updateNode(fiber.dom, fiber.alternate.props, fiber.props);\n  }\n\n  commitWork(fiber.child);\n  commitWork(fiber.sibling);\n}\n\nfunction commitDeletion(fiber, domParent) {\n  if (fiber.dom) {\n    domParent.removeChild(fiber.dom);\n  } else {\n    commitDeletion(fiber.child, domParent);\n  }\n}\n\nexport function useState(initial) {\n  // return [val, setVal]\n  const oldHook = wipFiber.alternate && wipFiber.alternate.hooks && wipFiber.alternate.hooks[hookIndex];\n  const hook = {\n    state: oldHook ? oldHook.state : initial,\n    queue: []\n  };\n  const actions = oldHook ? oldHook.queue : [];\n  actions.forEach(action => {\n    action instanceof Function ? hook.state = action(hook.state) : hook.state = action;\n  });\n\n  const setState = action => {\n    hook.queue.push(action);\n    wipRoot = {\n      dom: currentRoot.dom,\n      props: currentRoot.props,\n      alternate: currentRoot\n    };\n    nextUnitOfWork = wipRoot;\n    deletions = []; // requestIdleCallback(workLoop);\n  };\n\n  wipFiber.hooks.push(hook);\n  hookIndex++;\n  return [hook.state, setState];\n}\nexport default {\n  render\n};","map":{"version":3,"sources":["/Users/caipeng/coding/React/mini-react/src/client/react-dom.js"],"names":["nextUnitOfWork","wipRoot","currentRoot","wipFiber","hookIndex","deletions","render","element","container","dom","props","children","alternate","_createNode","fiber","node","type","document","createTextNode","nodeValue","createElement","_updateNode","isProperty","key","isEvent","isNew","prev","next","isGone","startsWith","prevProps","nextProps","Object","keys","filter","forEach","eventType","toLocaleLowerCase","substring","removeEventListener","addEventListener","requestIdleCallback","workLoop","deadline","shouldYield","performUnitOfWork","timeRemaining","commitRoot","isFunctionComponent","Function","_updateFunctionComponent","_updateHostComponent","child","nextFiber","sibling","parent","reconcileChildren","elements","index","oldFiber","prevSibling","length","newFiber","isSameType","effectTag","push","hooks","commitWork","domParentFiber","domParent","appendChild","commitDeletion","removeChild","useState","initial","oldHook","hook","state","queue","actions","action","setState"],"mappings":"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","sourcesContent":["\n\nlet nextUnitOfWork = null;\nlet wipRoot = null;\nlet currentRoot = null;\n\nlet wipFiber = null;\nlet hookIndex = null;\n\nlet deletions = null; // 要删除的项的数组\n\n/**\n * \n * @param {Object} element \n * @param {Element} container \n */\nfunction render(element, container) {\n    wipRoot = {\n        dom: container,\n        props: {\n            children: [element]\n        },\n        alternate: currentRoot,\n    }\n    deletions = [];\n\n    nextUnitOfWork = wipRoot;\n}\n\nfunction _createNode(fiber) {\n    let node = null;\n    let { type, props } = fiber;\n\n    if (type === 'TEXT_ELEMENT' ) {\n        node = document.createTextNode(props.nodeValue);\n    } else {\n        node = document.createElement(type);\n        _updateNode(node, {}, props);\n    }\n\n    // container.appendChild(node);\n    return node;\n}\n\nconst isProperty = key => key !== 'children' && !isEvent(key);\nconst isNew = (prev, next) => key => prev[key] !== next[key];\nconst isGone = (prev, next) => key => !(key in next);\nconst isEvent = key => key.startsWith('on');\n\nfunction _updateNode(node, prevProps, nextProps) {\n    // remove old event or change event listeners\n    Object.keys(prevProps)\n        .filter(isEvent)\n        .filter(\n            key => !(key in nextProps) || isNew(prevProps, nextProps)(key)\n        )\n        .forEach(key => {\n            const eventType = key.toLocaleLowerCase().substring(2);\n            node.removeEventListener(eventType, prevProps[key]);\n        })\n    \n    // add new event listeners\n    Object.keys(nextProps)\n        .filter(isEvent)\n        .filter(isNew(prevProps, nextProps))\n        .forEach(\n            key => {\n                const eventType = key.toLocaleLowerCase().substring(2);\n                node.addEventListener(eventType, nextProps[key]);\n            }\n        )\n\n    // remove old properties\n    Object.keys(prevProps)\n        .filter(isProperty)\n        .filter(isGone(prevProps, nextProps))\n        .forEach(key => {\n            node[key] = ''\n        })\n\n    // set new properties or change properties\n    Object.keys(nextProps)\n        .filter(isProperty)\n        .filter(isNew(prevProps, nextProps))\n        .forEach(key => {\n            node[key] = nextProps[key];\n        });\n    // nextProps.children.forEach(child => _createNode(child, node));\n}\n\nrequestIdleCallback(workLoop);\n\nfunction workLoop(deadline) {\n    let shouldYield = false;\n    // 循环任务\n    while(nextUnitOfWork && !shouldYield) {\n        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n        shouldYield = deadline.timeRemaining() < 1;\n    }\n\n    // 提交任务\n    if (!nextUnitOfWork && wipRoot) {\n        commitRoot();\n    }\n\n    requestIdleCallback(workLoop);\n}\n\n// 执行任务，并返回下一个任务\nfunction performUnitOfWork(fiber) {\n    const isFunctionComponent = fiber.type instanceof Function;\n\n    if (isFunctionComponent) {\n        _updateFunctionComponent(fiber);\n    } else {\n        _updateHostComponent(fiber);\n    }\n\n    // add dom node\n    // if (!fiber.dom) {\n    //     fiber.dom = _createNode(fiber);\n    // }\n\n    // create new fibers\n    // const elements = fiber.props.children;\n\n    // reconcileChildren(fiber, elements);\n\n    // return next unit of work\n    if (fiber.child) {\n        return fiber.child;\n    }\n    let nextFiber = fiber;\n    while(nextFiber) {\n        if (nextFiber.sibling) {\n            return nextFiber.sibling;\n        }\n        nextFiber = nextFiber.parent;\n    }\n}\n\nfunction reconcileChildren(fiber, elements) {\n    let index = 0;\n    let oldFiber = fiber.alternate && fiber.alternate.child;\n\n    let prevSibling = null;\n\n    while(index < elements.length || oldFiber != null) {\n        const element = elements[index];\n        let newFiber = null;\n\n        // compare oldFiber and newFiber\n        const isSameType = oldFiber && element && element.type === oldFiber.type;\n\n        if (isSameType) { // 相同的type ===》 update\n            newFiber = {\n                type: oldFiber.type,\n                props: element.props,\n                parent: fiber,\n                dom: oldFiber.dom,\n                alternate: oldFiber,\n                effectTag: \"UPDATE\"\n            }\n        }\n        if (!isSameType && element) { // 不同的type，且有element ===》 add\n            newFiber = {\n                type: element.type,\n                props: element.props,\n                parent: fiber,\n                dom: null,\n                alternate: null,\n                effectTag: \"PLACEMENT\"\n            }\n        }\n        if (!isSameType && oldFiber) { // 不同的type，且有oldFiber ===》 delete\n            oldFiber.effectTag = \"DELETE\";\n            deletions.push(oldFiber);\n        }\n\n        if (index === 0) {\n            fiber.child = newFiber;\n        } else {\n            prevSibling.sibling = newFiber\n        }\n\n        if (oldFiber) {\n            oldFiber = oldFiber.sibling;\n        }\n\n        prevSibling = newFiber;\n        index ++;\n    }\n}\n\nfunction _updateHostComponent(fiber) {\n    // add dom node\n    if (!fiber.dom) {\n        fiber.dom = _createNode(fiber);\n    }\n\n    // create new fibers\n    const elements = fiber.props.children;\n    reconcileChildren(fiber, elements);\n}\n\nfunction _updateFunctionComponent(fiber) {\n    wipFiber = fiber;\n    hookIndex = 0;\n    wipFiber.hooks = [];\n\n    const elements = [fiber.type(fiber.props)];\n    reconcileChildren(fiber, elements);\n}\n\nfunction commitRoot() {\n    deletions.forEach(commitWork); // 删除\n\n    commitWork(wipRoot.child);\n    currentRoot = wipRoot;\n    wipRoot = null; // 置空wipRoot\n}\n\n// 递归wipRoot\nfunction commitWork(fiber) {\n    if (!fiber) {\n        return;\n    }\n    // const domParent = fiber.parent.dom;\n    let domParentFiber = fiber.parent;\n    while(!domParentFiber.dom) {\n        domParentFiber = domParentFiber.parent;\n    }\n    const domParent = domParentFiber.dom;\n\n    if (fiber.effectTag === 'PLACEMENT' && fiber.dom != null) {\n        domParent.appendChild(fiber.dom);\n    }\n    if (fiber.effectTag === 'DELETE') {\n        // domParent.removeChild(fiber.dom);\n        commitDeletion(fiber, domParent);\n    }\n    if (fiber.effectTag === 'UPDATE' && fiber.dom !== null) {\n        _updateNode(fiber.dom, fiber.alternate.props, fiber.props);\n    }\n\n    commitWork(fiber.child);\n    commitWork(fiber.sibling);\n}\n\nfunction commitDeletion(fiber, domParent) {\n    if (fiber.dom) {\n        domParent.removeChild(fiber.dom);\n    } else {\n        commitDeletion(fiber.child, domParent);\n    }\n}\n\nexport function useState(initial) {\n    // return [val, setVal]\n    const oldHook = wipFiber.alternate && wipFiber.alternate.hooks && wipFiber.alternate.hooks[hookIndex];\n    const hook = {\n        state: oldHook ? oldHook.state : initial,\n        queue: []\n    }\n\n    const actions = oldHook ? oldHook.queue : [];\n    actions.forEach(action => {\n        action instanceof Function ?\n            hook.state = action(hook.state) :\n            hook.state = action\n    })\n\n\n    const setState = action => {\n        hook.queue.push(action);\n        wipRoot = {\n            dom: currentRoot.dom,\n            props: currentRoot.props,\n            alternate: currentRoot\n        }\n\n        nextUnitOfWork = wipRoot;\n        deletions = [];\n\n        // requestIdleCallback(workLoop);\n    }\n\n    wipFiber.hooks.push(hook)\n    hookIndex ++;\n    return [hook.state, setState];\n}\n\nexport default {\n    render\n}"]},"metadata":{},"sourceType":"module"}